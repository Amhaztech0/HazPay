
-- MESSAGE REQUEST SYSTEM
-- This script sets up a professional message request system.
-- 1. Creates a `contacts` table to manage user connections.
-- 2. Creates a `message_requests` table for handling new chat requests.
-- 3. Creates a function `can_send_message` to check if two users can communicate.
-- 4. Updates RLS policies on `messages` to use this new system.

BEGIN;

-- 1. Contacts Table
-- Stores accepted connections between users.
CREATE TABLE IF NOT EXISTS public.contacts (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id_1 UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    user_id_2 UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    UNIQUE(user_id_1, user_id_2)
);

-- RLS for contacts table
ALTER TABLE public.contacts ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view their own contacts" ON public.contacts;
CREATE POLICY "Users can view their own contacts"
ON public.contacts
FOR SELECT
USING (
    auth.uid() = user_id_1 OR auth.uid() = user_id_2
);

DROP POLICY IF EXISTS "Users can create their own contacts" ON public.contacts;
CREATE POLICY "Users can create their own contacts"
ON public.contacts
FOR INSERT
WITH CHECK (
    auth.uid() = user_id_1 OR auth.uid() = user_id_2
);


-- 2. Message Requests Table
-- Manages pending, accepted, or declined chat requests.
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_type WHERE typname = 'request_status'
  ) THEN
    CREATE TYPE public.request_status AS ENUM ('pending', 'accepted', 'declined');
  END IF;
END;
$$;

CREATE TABLE IF NOT EXISTS public.message_requests (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    sender_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    receiver_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    status public.request_status DEFAULT 'pending' NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    updated_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    UNIQUE(sender_id, receiver_id)
);

-- RLS for message_requests table
ALTER TABLE public.message_requests ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can manage their own message requests" ON public.message_requests;
CREATE POLICY "Users can manage their own message requests"
ON public.message_requests
FOR ALL
USING (
    auth.uid() = sender_id OR auth.uid() = receiver_id
);


-- 3. can_send_message Function
-- Checks if two users are contacts.
CREATE OR REPLACE FUNCTION public.can_send_message(
    p_sender_id UUID,
    p_receiver_id UUID
)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1
        FROM public.contacts
        WHERE
            (user_id_1 = p_sender_id AND user_id_2 = p_receiver_id) OR
            (user_id_1 = p_receiver_id AND user_id_2 = p_sender_id)
    );
END;
$$;


-- 4. Update RLS Policy for `messages` table
-- This is the core of the new system. It prevents messages unless users are contacts.
-- First, drop the old policy that might be blocking messages.
-- The error "You cannot send messages to this user" suggests a restrictive policy exists.
-- We will replace it with a more flexible one that uses our new function.

-- Let's drop a policy that might exist from a previous setup.
-- This is a guess based on the error message.
DROP POLICY IF EXISTS "Users can only message non-blocked users" ON public.messages;
DROP POLICY IF EXISTS "Users can insert their own messages" ON public.messages;

-- New policy for inserting messages
-- Users can send messages if they are contacts with the other user in the chat
CREATE POLICY "Users can insert messages if they are contacts"
ON public.messages
FOR INSERT
WITH CHECK (
    auth.uid() = sender_id AND
    (
        -- Get the other user from the chat and check if they are contacts
        public.can_send_message(
            auth.uid(), 
            (
                SELECT CASE 
                    WHEN user1_id = auth.uid() THEN user2_id 
                    ELSE user1_id 
                END
                FROM public.chats 
                WHERE id = chat_id
            )
        )
    )
);

-- Ensure users can still read messages in their chats.
DROP POLICY IF EXISTS "Users can read messages in their chats" ON public.messages;
CREATE POLICY "Users can read messages in their chats"
ON public.messages
FOR SELECT
USING (
    chat_id IN (
        SELECT id FROM public.chats
        WHERE auth.uid() = user1_id OR auth.uid() = user2_id
    )
);


-- 5. Function to handle sending a message request
CREATE OR REPLACE FUNCTION public.send_message_request(
    p_receiver_id UUID
)
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_sender_id UUID := auth.uid();
    v_request_id UUID;
    v_status public.request_status;
BEGIN
    -- Prevent sending request to self
    IF v_sender_id = p_receiver_id THEN
        RETURN json_build_object('success', false, 'message', 'You cannot send a message request to yourself.');
    END IF;

    -- Check if they are already contacts
    IF public.can_send_message(v_sender_id, p_receiver_id) THEN
        RETURN json_build_object('success', false, 'message', 'You are already contacts with this user.');
    END IF;

    -- Check for existing request
    SELECT id, status INTO v_request_id, v_status FROM public.message_requests
    WHERE (sender_id = v_sender_id AND receiver_id = p_receiver_id)
       OR (sender_id = p_receiver_id AND receiver_id = v_sender_id);

    IF v_request_id IS NOT NULL THEN
        IF v_status = 'pending' THEN
            RETURN json_build_object('success', true, 'message', 'A request is already pending.');
        ELSIF v_status = 'declined' THEN
            -- Allow re-sending a request if it was declined
            UPDATE public.message_requests
            SET status = 'pending', sender_id = v_sender_id, receiver_id = p_receiver_id, updated_at = NOW()
            WHERE id = v_request_id;
            RETURN json_build_object('success', true, 'message', 'Message request sent.');
        ELSE -- accepted
            RETURN json_build_object('success', false, 'message', 'You are already contacts.');
        END IF;
    END IF;

    -- Create new request
    INSERT INTO public.message_requests (sender_id, receiver_id)
    VALUES (v_sender_id, p_receiver_id);

    RETURN json_build_object('success', true, 'message', 'Message request sent.');
END;
$$;


-- 6. Function to accept a message request
CREATE OR REPLACE FUNCTION public.accept_message_request(
    p_request_id UUID
)
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_request public.message_requests;
    v_receiver_id UUID := auth.uid();
BEGIN
    SELECT * INTO v_request FROM public.message_requests WHERE id = p_request_id;

    -- Validate that the current user is the receiver
    IF v_request.receiver_id != v_receiver_id THEN
        RETURN json_build_object('success', false, 'message', 'You are not authorized to accept this request.');
    END IF;

    -- Update request status
    UPDATE public.message_requests
    SET status = 'accepted', updated_at = NOW()
    WHERE id = p_request_id;

    -- Create a contact entry for both directions
    INSERT INTO public.contacts (user_id_1, user_id_2)
    VALUES (v_request.sender_id, v_request.receiver_id)
    ON CONFLICT (user_id_1, user_id_2) DO NOTHING;

    INSERT INTO public.contacts (user_id_1, user_id_2)
    VALUES (v_request.receiver_id, v_request.sender_id)
    ON CONFLICT (user_id_1, user_id_2) DO NOTHING;

    RETURN json_build_object('success', true, 'message', 'Message request accepted.');
END;
$$;


-- 7. Function to decline a message request
CREATE OR REPLACE FUNCTION public.decline_message_request(
    p_request_id UUID
)
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_request public.message_requests;
    v_user_id UUID := auth.uid();
BEGIN
    SELECT * INTO v_request FROM public.message_requests WHERE id = p_request_id;

    -- Validate that the current user is part of the request
    IF v_request.receiver_id != v_user_id AND v_request.sender_id != v_user_id THEN
        RETURN json_build_object('success', false, 'message', 'You are not authorized to decline this request.');
    END IF;

    -- Update request status
    UPDATE public.message_requests
    SET status = 'declined', updated_at = NOW()
    WHERE id = p_request_id;

    RETURN json_build_object('success', true, 'message', 'Message request declined.');
END;
$$;


COMMIT;
